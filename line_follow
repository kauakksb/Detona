def line_follow(self,distance,speed,proportional = 1.4):
        self.reset()
        self.drive.distance()
        self.set_speed(speed)

        # Define os valores de preto e de branco caso eles não tenham sido definidos na calibração
        if self.black == 0:
            self.black = 6
            self.white = 91
        
        threshold = (self.black + self.white) / 2 # Calcula a méida dos valores de preto e branco
        pi = 3.14 # Define o valor de pi

        # Executará o código enquanto o robô não tiver percorrido a distância definida
        while distance > self.drive.distance():
            
            # Mede o desvio,calcula a correção a ser feita e então a executa
            reflection_line_follower = self.front_s_color.get_value('reflection') # Valor de reflexão do sensor
            deviation = reflection_line_follower - threshold # Calculando o desvio feito pelo robô
            self.error_correction = deviation * proportional # Calculando a correção a ser feita pelo robô
            self.drive.drive(speed,self.error_correction) # Executando a correção
        self.drive.stop() 

        def line_follow(self,distance,speed,kp = 1.4,ki = 0.000005,kd = 3):
        self.reset()
        self.drive.distance()
        self.set_speed(speed)

        # Define os valores de preto e de branco caso eles não tenham sido definidos na calibração
        if self.black == 0:
            self.black = 6
            self.white = 91
        
        threshold = (self.black + self.white) / 2 # Calcula a méida dos valores de preto e branco
        pi = 3.14 # Define o valor de pi
        deviation = 0
        integral = 0
        derivate = 0 
        last_error = 0

        # Executará o código enquanto o robô não tiver percorrido a distância definida
        while distance > self.drive.distance():
            # Mede o desvio,calcula a correção a ser feita e então a executa
            reflection_line_follower = self.front_s_color.get_value('reflection') # Valor de reflexão do sensor
            deviation = reflection_line_follower - threshold # Calculando o desvio feito pelo robô
            integral = integral + deviation
            last_error = deviation
            derivate = deviation - last_error
            self.error_correction =kp *(deviation + ki * integral + kd * derivate)# Calculando a correção a ser feita pelo robô
            self.drive.drive(speed,self.error_correction) # Executando a correção
        self.drive.stop() 